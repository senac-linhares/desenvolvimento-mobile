<h1>Stateless vs Stateful Widgets</h1>

<p>No Flutter, quase tudo √© um <strong>Widget</strong>. Entender a diferen√ßa entre widgets que "t√™m estado" e os que
    "n√£o t√™m" √© o divisor de √°guas entre criar uma interface est√°tica e um aplicativo interativo.</p>

<div class="hero-section"
    style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 40px; border-radius: 12px; margin-bottom: 40px;">
    <h2 style="color: white; border: none; margin-top: 0;">Reatividade √© a Chave</h2>
    <p>O Flutter √© um framework reativo: quando o estado de um widget muda, ele se redesenha automaticamente para
        refletir essa mudan√ßa.</p>
</div>

<div class="tree-diagram"
    style="margin: 40px 0; padding: 20px; background: #f8fafc; border-radius: 12px; border: 1px solid var(--border);">
    <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
        <div
            style="padding: 10px 20px; background: #6366f1; color: white; border-radius: 6px; font-weight: bold; font-size: 0.9rem;">
            MaterialApp</div>
        <div style="height: 20px; width: 2px; background: #cbd5e1;"></div>
        <div
            style="padding: 10px 20px; background: #818cf8; color: white; border-radius: 6px; font-weight: bold; font-size: 0.9rem;">
            Scaffold</div>
        <div style="display: flex; gap: 40px; margin-top: 10px;">
            <div style="display: flex; flex-direction: column; align-items: center;">
                <div style="height: 20px; width: 2px; background: #cbd5e1;"></div>
                <div
                    style="padding: 8px 15px; background: #94a3b8; color: white; border-radius: 6px; font-size: 0.8rem;">
                    AppBar</div>
            </div>
            <div style="display: flex; flex-direction: column; align-items: center;">
                <div style="height: 20px; width: 2px; background: #cbd5e1;"></div>
                <div
                    style="padding: 10px 20px; background: #3b82f6; color: white; border-radius: 6px; font-weight: bold; font-size: 0.8rem;">
                    Center</div>
                <div style="height: 20px; width: 2px; background: #cbd5e1;"></div>
                <div
                    style="padding: 8px 15px; background: #10b981; color: white; border-radius: 6px; font-size: 0.8rem;">
                    Text</div>
            </div>
        </div>
    </div>
</div>

<h2>1. StatelessWidget: A Imutabilidade</h2>
<p>Um <strong>StatelessWidget</strong> √© "burro" no bom sentido. Ele recebe dados e os exibe. Ele n√£o pode mudar sozinho
    ap√≥s ser constru√≠do.</p>

<div style="background: #f1f5f9; padding: 20px; border-radius: 8px; margin: 20px 0;">
    <pre><code class="language-dart">class MeuTexto extends StatelessWidget {
  final String conteudo;
  
  const MeuTexto(this.conteudo);

  @override
  Widget build(BuildContext context) {
    return Text(conteudo);
  }
}</code></pre>
    <p style="font-size: 0.9rem;"><strong>Importante:</strong> Se as propriedades de um StatelessWidget mudarem (vindas
        do Widget pai), o Flutter simplesmente destr√≥i o objeto antigo e cria um NOVO. Widgets s√£o baratos de criar.</p>
</div>

<h2>2. StatefulWidget: Onde a M√°gica Acontece</h2>
<p>Diferente do anterior, o <strong>StatefulWidget</strong> √© composto por duas classes: a classe do Widget (que √©
    imut√°vel) e a classe do <strong>State</strong> (que √© mut√°vel e persistente).</p>

<div class="callout info">
    <div class="callout-title">üß† Mem√≥ria de Longo Prazo</div>
    O segredo est√° no <strong>Element Tree</strong>. Enquanto os Widgets s√£o destru√≠dos a cada frame, o
    <strong>Element</strong> correspondente na √°rvore mant√©m a refer√™ncia para o objeto <strong>State</strong>,
    permitindo que ele sobreviva entre um rebuild e outro.
</div>

<h3>A Fun√ß√£o setState() e o Escopo de Rebuild</h3>
<p>Ao chamar <code>setState(() {...})</code>, voc√™ marca o widget como "sujo" (dirty). Na pr√≥xima atualiza√ß√£o de tela, o
    Flutter executar√° o m√©todo <code>build</code> apenas deste widget e de seus filhos.</p>

<div style="background: #fff5f5; border: 1px solid #feb2b2; padding: 15px; border-radius: 8px; margin: 20px 0;">
    <strong>Dica de S√™nior:</strong> N√£o coloque l√≥gica pesada dentro do <code>build</code>. Como ele pode ser chamado
    60 ou 120 vezes por segundo, qualquer c√°lculo lento vai travar a interface do seu aluno.
</div>

<h2>3. O papel das Keys</h2>
<p>As <code>Keys</code> s√£o essenciais quando voc√™ tem uma lista de StatefulWidgets (ex: uma lista de tarefas onde voc√™
    pode deletar itens). Sem Keys, o Flutter pode se confundir e "atribuir" o estado de um item deletado ao novo item
    que subiu na lista.</p>

<pre><code class="language-dart">// O uso de ValueKey garante que o estado siga o item correto
ItemTarefa(key: ValueKey(tarefa.id), tarefa: tarefa);</code></pre>

<h2>4. O Ciclo de Vida do Estado (Expandido)</h2>
<p>Al√©m do b√°sico, entenda estes momentos cr√≠ticos:</p>
<ul>
    <li><strong>didUpdateWidget():</strong> Chamado quando o widget pai reconstr√≥i e passa novos dados para este widget,
        mas voc√™ quer comparar o valor antigo com o novo.</li>
    <li><strong>didChangeDependencies():</strong> Chamado logo ap√≥s o <code>initState</code> e quando um objeto que este
        widget depende (via InheritedWidget) muda.</li>
</ul>

<div class="callout tip">
    <div class="callout-title">üöÄ Dica de Performance</div>
    Sempre prefira o <strong>StatelessWidget</strong> sempre que poss√≠vel. Ele √© mais leve para o sistema. S√≥ use
    <strong>Stateful</strong> se os dados precisarem mudar enquanto o usu√°rio est√° na tela.
</div>

<hr style="margin: 40px 0;">

<h2>üéØ Desafio de L√≥gica</h2>
<p>Voc√™ est√° criando uma tela de "Perfil de Usu√°rio". Nesta tela temos:</p>
<ol>
    <li>O nome do usu√°rio (que nunca muda).</li>
    <li>Uma foto de capa fixa.</li>
    <li>Um bot√£o "Seguir" que muda de cor e texto quando clicado.</li>
</ol>

<div style="background: #fff; border: 2px dashed var(--primary); padding: 20px; border-radius: 8px; margin-top: 20px;">
    <p><strong>Quais desses componentes devem ser Stateless e quais devem ser Stateful?</strong></p>
</div>

<details style="margin-top: 20px; cursor: pointer; background: #f3f4f6; padding: 15px; border-radius: 8px;">
    <summary><strong>Ver Solu√ß√£o</strong></summary>
    <div style="margin-top: 10px;">
        <ul>
            <li><strong>Nome e Foto:</strong> Stateless (n√£o mudam durante a sess√£o).</li>
            <li><strong>Bot√£o "Seguir":</strong> Stateful (precisa mudar seu estado visual de "Seguir" para "Seguindo"
                ao ser clicado).</li>
            <li><strong>A Tela Inteira:</strong> Geralmente ser√° um StatefulWidget para gerenciar o estado do bot√£o
                interno e carregar dados.</li>
        </ul>
    </div>
</details>

<div class="callout warning">
    <div class="callout-title">‚ö†Ô∏è Curiosidade</div>
    Internamente, at√© o <code>Scaffold</code> √© um Widget. No Flutter, voc√™ constr√≥i widgets complexos compondo widgets
    mais simples.
</div>